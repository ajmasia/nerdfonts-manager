#!/usr/bin/env bash

set -u

# Color support (for help output)
supports_color() {
  if [ -t 1 ]; then
    [ -z "${NO_COLOR:-}" ] || return 1
    if command -v tput >/dev/null 2>&1; then
      [ "$(tput colors 2>/dev/null || echo 0)" -ge 8 ] && return 0
    else
      return 0
    fi
  fi
  return 1
}

if supports_color; then
  if command -v tput >/dev/null 2>&1; then
    BOLD="$(tput bold)"
    DIM="$(tput dim 2>/dev/null || printf $'\e[2m')"
    RESET="$(tput sgr0)"
    CYAN="$(tput setaf 6)"
    GREEN="$(tput setaf 2)"
    YELLOW="$(tput setaf 3)"
    RED="$(tput setaf 1)"
  else
    BOLD=$'\e[1m'
    DIM=$'\e[2m'
    RESET=$'\e[0m'
    CYAN=$'\e[36m'
    GREEN=$'\e[32m'
    YELLOW=$'\e[33m'
    RED=$'\e[31m'
  fi
else
  BOLD=''
  DIM=''
  RESET=''
  CYAN=''
  GREEN=''
  YELLOW=''
  RED=''
fi

# Config
fzf_args=(
  --multi
  --header=$'📝 Nerd Font Manager\n[Tab] select multiple, [Enter] confirm'
)
fonts_dir="${NERDFONTS_DIR:-$HOME/.fonts}"

available_fonts=(
  "0xProto" "3270" "AdwaitaMono" "Agave" "AnonymousPro" "Arimo"
  "AtkinsonHyperlegibleMono" "AurulentSansMono" "BigBlueTerminal"
  "BitstreamVeraSansMono" "BlexMono" "CascadiaMono" "CascadiaCode"
  "CodeNewRoman" "ComicShannsMono" "CommitMono" "Cousine" "D2Coding"
  "DaddyTimeMono" "DejaVuSansMono" "DepartureMono" "DroidSansMono"
  "EnvyCodeR" "FantasqueSansMono" "FiraCode" "FiraMono" "GeistMono"
  "Go-Mono" "Gohu" "Hack" "Hasklig" "HeavyData" "Hermit" "iA-Writer"
  "Inconsolata" "InconsolataGo" "InconsolataLGC" "IntelOneMono"
  "Iosevka" "IosevkaTerm" "IosevkaTermSlab" "JetBrainsMono" "Lekton"
  "LiberationMono" "Lilex" "MartianMono" "Meslo" "Monaspace" "Monofur"
  "Monoid" "Mononoki" "MPlus" "Noto" "OpenDyslexic" "Overpass"
  "ProFont" "ProggyClean" "Recursive" "RobotoMono" "ShureTechMono"
  "SauceCodePro" "SpaceMono" "NerdFontsSymbolsOnly" "Terminus" "Tinos"
  "Ubuntu" "UbuntuMono" "UbuntuSans" "VictorMono" "ZedMono"
)

script_name="$(basename -- "${BASH_SOURCE[0]:-$0}")"

# Utils
die() {
  echo "❌ $*" >&2
  exit 1
}

require_cmd() { command -v "$1" >/dev/null 2>&1 || die "You need '$1' installed."; }

# ONE-TIME dependency check
_have() { command -v "$1" >/dev/null 2>&1; }

# Detect distro / package manager and Nix
_detect_pkg_targets() {
  DETECTED="unknown"
  HAS_NIX=0

  # Check if Nix is available regardless of the distro
  if command -v nix >/dev/null 2>&1; then HAS_NIX=1; fi

  # Read /etc/os-release to get ID and ID_LIKE when available
  if [ -r /etc/os-release ]; then . /etc/os-release; fi
  local id="${ID:-}" like="${ID_LIKE:-}"

  # Heuristics by package manager commands and os-release IDs
  if command -v pacman >/dev/null 2>&1 || [[ "$id" =~ (arch|artix) || "$like" =~ arch ]]; then
    DETECTED="arch"
  elif command -v dnf >/dev/null 2>&1 || [[ "$id" =~ fedora || "$like" =~ (fedora|rhel|centos) ]]; then
    DETECTED="fedora"
  elif command -v apt >/dev/null 2>&1 || command -v apt-get >/dev/null 2>&1 ||
    [[ "$id" =~ (debian|ubuntu|linuxmint|pop) || "$like" =~ (debian|ubuntu) ]]; then
    DETECTED="debian"
  elif [[ "$id" = "nixos" ]]; then
    DETECTED="nixos"
  fi
}

# Remove duplicates while preserving order; prints space-separated list
_join_unique() {
  declare -A seen=()
  local out=() x
  for x in "$@"; do
    [[ -n "$x" && -z "${seen[$x]:-}" ]] && {
      out+=("$x")
      seen["$x"]=1
    }
  done
  printf '%s' "${out[*]}"
}

# OS-specific install help (with Nix when available)
# Arguments: list of missing deps (e.g., fzf unzip fc-cache curl|wget)
# Prints colored, distro-appropriate install commands; exits is handled by caller.
_print_install_help() {
  local missing=("$@")

  # Build per-distro package/attribute lists
  local apt_pkgs=() dnf_pkgs=() pac_pkgs=() nix_attrs=()

  for m in "${missing[@]}"; do
    case "$m" in
    fzf)
      apt_pkgs+=("fzf")
      dnf_pkgs+=("fzf")
      pac_pkgs+=("fzf")
      nix_attrs+=("fzf")
      ;;
    unzip)
      apt_pkgs+=("unzip")
      dnf_pkgs+=("unzip")
      pac_pkgs+=("unzip")
      nix_attrs+=("unzip")
      ;;
    fc-cache)
      # fc-cache is provided by fontconfig
      apt_pkgs+=("fontconfig")
      dnf_pkgs+=("fontconfig")
      pac_pkgs+=("fontconfig")
      nix_attrs+=("fontconfig")
      ;;
    curl\|wget | curl | wget)
      # You only need one; show both so the user can choose
      apt_pkgs+=("curl" "wget")
      dnf_pkgs+=("curl" "wget")
      pac_pkgs+=("curl" "wget")
      nix_attrs+=("curl" "wget")
      ;;
    *)
      apt_pkgs+=("$m")
      dnf_pkgs+=("$m")
      pac_pkgs+=("$m")
      nix_attrs+=("$m")
      ;;
    esac
  done

  # Deduplicate each list
  local apt_line dnf_line pac_line nix_line
  apt_line="$(_join_unique "${apt_pkgs[@]}")"
  dnf_line="$(_join_unique "${dnf_pkgs[@]}")"
  pac_line="$(_join_unique "${pac_pkgs[@]}")"
  nix_line="$(_join_unique "${nix_attrs[@]}")"

  # Build nix profile refs (nixpkgs#attr)
  local nix_refs=() a
  for a in $nix_line; do nix_refs+=("nixpkgs#$a"); done

  # Detect platform and Nix presence
  _detect_pkg_targets

  printf '%s\n' "${RED}${BOLD}Missing dependencies:${RESET} ${missing[*]}" >&2
  echo >&2

  # Show Nix if available (either on NixOS or any system with nix in PATH)
  if [ "$HAS_NIX" -eq 1 ] || [ "$DETECTED" = "nixos" ]; then
    printf '%s\n' "${BOLD}Nix/NixOS${RESET} ${DIM}(detected)${RESET}:" >&2
    printf '  %b\n' "${GREEN}nix profile install ${nix_refs[*]}${RESET}" >&2
    echo >&2
  fi

  # Show only the detected distro; if unknown, show the three common ones
  case "$DETECTED" in
  debian)
    printf '%s\n' "${BOLD}Debian/Ubuntu${RESET} ${DIM}(detected)${RESET}:" >&2
    printf '  %b\n' "${GREEN}sudo apt update && sudo apt install -y ${apt_line}${RESET}" >&2
    ;;
  fedora)
    printf '%s\n' "${BOLD}Fedora${RESET} ${DIM}(detected)${RESET}:" >&2
    printf '  %b\n' "${GREEN}sudo dnf install -y ${dnf_line}${RESET}" >&2
    ;;
  arch)
    printf '%s\n' "${BOLD}Arch Linux${RESET} ${DIM}(detected)${RESET}:" >&2
    printf '  %b\n' "${GREEN}sudo pacman -Syu --needed ${pac_line}${RESET}" >&2
    ;;
  nixos)
    # Nix command already shown above; no extra system package step
    :
    ;;
  *)
    # Unknown distro: show generic instructions for the three main families
    printf '%s\n' "${BOLD}Debian/Ubuntu${RESET}:" >&2
    printf '  %b\n' "${GREEN}sudo apt update && sudo apt install -y ${apt_line}${RESET}" >&2
    echo >&2
    printf '%s\n' "${BOLD}Fedora${RESET}:" >&2
    printf '  %b\n' "${GREEN}sudo dnf install -y ${dnf_line}${RESET}" >&2
    echo >&2
    printf '%s\n' "${BOLD}Arch Linux${RESET}:" >&2
    printf '  %b\n' "${GREEN}sudo pacman -Syu --needed ${pac_line}${RESET}" >&2
    ;;
  esac

  # Hint when curl|wget is in the missing list
  if printf '%s\n' "${missing[@]}" | grep -q 'curl|wget'; then
    echo >&2
    printf '%s\n' "${DIM}Note: you only need one of 'curl' or 'wget'.${RESET}" >&2
  fi
}

preflight_check() {
  # Full set so se comprueban siempre independientemente de la opción
  local required=(fzf unzip fc-cache curl\|wget)
  local missing=()
  for dep in "${required[@]}"; do
    case "$dep" in
    curl\|wget) (_have curl || _have wget) || missing+=("curl|wget") ;;
    *) _have "$dep" || missing+=("$dep") ;;
    esac
  done
  if ((${#missing[@]})); then
    _print_install_help "${missing[@]}"
    exit 1
  fi
}

# Decide downloader (after preflight guarantees at least one)
set_downloader() {
  if command -v curl >/dev/null 2>&1; then
    DL='curl -s -OL'
  elif command -v wget >/dev/null 2>&1; then
    DL='wget -q'
  else
    die "No downloader found (curl/wget)."
  fi
}

# Help functions
help_global() {
  cat <<EOF
${BOLD}${CYAN}Nerd Font Manager (nfm)${RESET}

${BOLD}Usage${RESET}:
  $script_name ${GREEN}<command>${RESET} [args]  ${DIM}(use -h for command help)${RESET}

${BOLD}Commands${RESET}:
  ${GREEN}list, l${RESET}                 List installed fonts
  ${GREEN}install, i${RESET} [FONT...]    Install fonts (interactive if none)
  ${GREEN}uninstall, u${RESET} [FONT...]  Uninstall fonts (interactive if none)

${BOLD}Global options${RESET}:
  ${GREEN}-h, --help${RESET}              Show this help

${BOLD}Notes${RESET}:
  • Fonts directory: \$NERDFONTS_DIR ${DIM}(default: ${HOME}/.fonts)${RESET}
  • Dependencies: All fonts are downloaded from the official Nerd Fonts site ${DIM}(https://www.nerdfonts.com/font-downloads)${RESET}

EOF
}

help_list() {
  cat <<EOF
${BOLD}${CYAN}Nerd Font Manager (nfm)${RESET}

${BOLD}Usage${RESET}: $script_name list
${DIM}List installed Nerd Fonts from $fonts_dir.${RESET}

EOF
}

help_install() {
  cat <<EOF
${BOLD}${CYAN}Nerd Font Manager (nfm)${RESET}

${BOLD}Usage${RESET}: $script_name install [FONT...]
Install one or more Nerd Fonts. If no FONT names are provided, an interactive fzf picker opens
Fonts are downloaded from the official Nerd Fonts site ${DIM}(https://www.nerdfonts.com/font-downloads)${RESET}


${BOLD}Examples${RESET}:
  ${GREEN}$script_name install                    ${RESET}Open fzf and select fonts
  ${GREEN}$script_name install ${RESET}FiraCode Meslo     Install specific fonts

EOF
}

help_uninstall() {
  cat <<EOF
${BOLD}${CYAN}Nerd Font Manager (nfm)${RESET}

${BOLD}Usage${RESET}: $script_name uninstall [FONT...]
Uninstall one or more Nerd Fonts. If no names are provided, an interactive fzf picker opens

${BOLD}Examples${RESET}:
  ${GREEN}$script_name uninstall            ${RESET}Open fzf and select installed fonts
  ${GREEN}$script_name uninstall ${RESET}Meslo      Remove a specific font

EOF
}

# Commands
list_fonts() {
  if [ ! -d "$fonts_dir" ]; then
    echo "❌ No fonts directory found at: $fonts_dir."
    exit 1
  fi
  echo "📚 Installed fonts in $fonts_dir:"
  # GNU find uses -printf; on BSD/macOS you can replace with basename variant.
  find "$fonts_dir" -mindepth 1 -maxdepth 1 -type d -printf "• ${GREEN}%f${RESET}\n"
}

load_installed_fonts() {
  mapfile -t installed_fonts < <(find "$fonts_dir" -mindepth 1 -maxdepth 1 -type d -printf "%f\n" 2>/dev/null || true)
}

install_fonts() {
  # subcommand-specific help
  if [[ "${1:-}" == "-h" || "${1:-}" == "--help" ]]; then
    help_install
    return 0
  fi
  shift 0

  require_cmd unzip
  if command -v curl >/dev/null 2>&1; then
    DL='curl -s -OL'
  elif command -v wget >/dev/null 2>&1; then
    DL='wget -q'
  else die "Neither 'curl' nor 'wget' is installed."; fi

  load_installed_fonts
  declare -A is_installed=()
  for f in "${installed_fonts[@]:-}"; do is_installed["$f"]=1; done

  local selection
  if [ "$#" -gt 0 ]; then
    selection=$(printf "%s\n" "$@")
  else
    local candidates=()
    for f in "${available_fonts[@]}"; do
      [[ -n "${is_installed[$f]:-}" ]] || candidates+=("$f")
    done
    if [ ${#candidates[@]} -eq 0 ]; then
      echo "✅ Nothing to install. You're up to date"
      return 0
    fi
    require_cmd fzf
    selection=$(printf "%s\n" "${candidates[@]}" |
      fzf "${fzf_args[@]}" --header=$'⬇️ Nerd Fonts Installer\n[Tab] select, [Enter] confirm')
    [ -n "$selection" ] || {
      echo "Aborting. ${RED}No font selected${RESET}"
      return 0
    }
  fi

  mkdir -p "$fonts_dir"

  while IFS= read -r font_name; do
    [ -n "$font_name" ] || continue
    if [ -d "$fonts_dir/$font_name" ]; then
      echo "⏭️  $font_name is already installed. Skipping"
      continue
    fi
    echo "🚀 Installing $font_name Nerd Font..."
    echo "⬇️  Downloading $font_name.zip..."
    if ! eval $DL "\"https://github.com/ryanoasis/nerd-fonts/releases/latest/download/${font_name}.zip\""; then
      echo "⚠️  Failed to download ${font_name}.zip. Skipping..."
      continue
    fi
    echo "📦 Unzipping to $fonts_dir/$font_name/"
    mkdir -p "$fonts_dir/$font_name"
    if ! unzip -q "$font_name.zip" -d "$fonts_dir/$font_name/"; then
      echo "⚠️  Failed to unzip ${font_name}.zip. Removing file..."
      rm -f "$font_name.zip"
      continue
    fi
    rm -f "$font_name.zip"
    echo "✅ $font_name installed."
  done <<<"$selection"

  echo "🔄 Refreshing font cache..."
  if command -v fc-cache >/dev/null 2>&1; then
    fc-cache -f >/dev/null || true
  else echo "ℹ️ 'fc-cache' not found; you may need to refresh the cache manually"; fi
  echo "🎉 Installation complete"
}

uninstall_fonts() {
  # subcommand-specific help
  if [[ "${1:-}" == "-h" || "${1:-}" == "--help" ]]; then
    help_uninstall
    return 0
  fi
  shift 0

  if [ ! -d "$fonts_dir" ]; then
    echo "❌ No fonts directory found at: $fonts_dir"
    exit 1
  fi

  mapfile -t installed_fonts < <(find "$fonts_dir" -mindepth 1 -maxdepth 1 -type d -printf "%f\n")
  if [ ${#installed_fonts[@]} -eq 0 ]; then
    echo "❌ No installed fonts found in $fonts_dir"
    exit 1
  fi

  local selection
  if [ "$#" -gt 0 ]; then
    selection=$(printf "%s\n" "$@")
  else
    require_cmd fzf
    selection=$(printf "%s\n" "${installed_fonts[@]}" |
      fzf --multi --header=$'🗑️ Font Uninstaller\n[Tab] select, [Enter] confirm')
    [ -n "$selection" ] || {
      echo "Aborting. ${RED}No font selected${RESET}"
      return 0
    }
  fi

  while IFS= read -r font; do
    [ -n "$font" ] || continue
    if [ ! -d "$fonts_dir/$font" ]; then
      echo "⚠️  $font is not installed. Skipping."
      continue
    fi
    echo "🗑️  Removing $font from $fonts_dir..."
    rm -rf "$fonts_dir/$font"
  done <<<"$selection"

  echo "🔄 Refreshing font cache..."
  if command -v fc-cache >/dev/null 2>&1; then fc-cache -f >/dev/null || true; fi
  echo "✅ Uninstallation complete"
}

# Parse command-line arguments
# Preflight: comprobar dependencias UNA SOLA VEZ al inicio
preflight_check

if [[ "${1:-}" == "-h" || "${1:-}" == "--help" || -z "${1:-}" ]]; then
  help_global
  exit 0
fi

cmd="$1"
shift

case "$cmd" in
list | l)
  if [[ "${1:-}" == "-h" || "${1:-}" == "--help" ]]; then
    help_list
    exit 0
  fi
  list_fonts
  ;;
install | i) install_fonts "$@" ;;
uninstall | u) uninstall_fonts "$@" ;;
*)
  echo "Unknown command: $cmd"
  echo
  echo "Use ${BOLD}${RED}$script_name -h${RESET} for usage information"
  exit 2
  ;;
esac
